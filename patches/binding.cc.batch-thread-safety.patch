diff --git a/src/binding.cc b/src/binding.cc
index c30ac76..e933861 100644
--- a/src/binding.cc
+++ b/src/binding.cc
@@ -1874,7 +1874,8 @@ struct Batch {
   Batch (Database* database)
     : database_(database),
       batch_(new leveldb::WriteBatch()),
-      hasData_(false) {}
+      hasData_(false),
+      isShared_(false) {}
 
   ~Batch () {
     delete batch_;
@@ -1901,9 +1902,22 @@ struct Batch {
     return database_->WriteBatch(options, batch_);
   }
 
+  bool IsShared () {
+    return isShared_;
+  }
+
+  void Share () {
+    isShared_ = true;
+  }
+
+  void Unshare () {
+    isShared_ = false;
+  }
+
   Database* database_;
   leveldb::WriteBatch* batch_;
   bool hasData_;
+  bool isShared_;
 };
 
 /**
@@ -1938,11 +1952,15 @@ NAPI_METHOD(batch_put) {
   NAPI_ARGV(3);
   NAPI_BATCH_CONTEXT();
 
-  leveldb::Slice key = ToSlice(env, argv[1]);
-  leveldb::Slice value = ToSlice(env, argv[2]);
-  batch->Put(key, value);
-  DisposeSliceBuffer(key);
-  DisposeSliceBuffer(value);
+  if (!batch->IsShared()) {
+    leveldb::Slice key = ToSlice(env, argv[1]);
+    leveldb::Slice value = ToSlice(env, argv[2]);
+    batch->Put(key, value);
+    DisposeSliceBuffer(key);
+    DisposeSliceBuffer(value);
+  } else {
+    napi_throw_error(env, 0, "Unsafe batch put.");
+  }
 
   NAPI_RETURN_UNDEFINED();
 }
@@ -1954,9 +1972,13 @@ NAPI_METHOD(batch_del) {
   NAPI_ARGV(2);
   NAPI_BATCH_CONTEXT();
 
-  leveldb::Slice key = ToSlice(env, argv[1]);
-  batch->Del(key);
-  DisposeSliceBuffer(key);
+  if (!batch->IsShared()) {
+    leveldb::Slice key = ToSlice(env, argv[1]);
+    batch->Del(key);
+    DisposeSliceBuffer(key);
+  } else {
+    napi_throw_error(env, 0, "Unsafe batch del.");
+  }
 
   NAPI_RETURN_UNDEFINED();
 }
@@ -1968,7 +1990,11 @@ NAPI_METHOD(batch_clear) {
   NAPI_ARGV(1);
   NAPI_BATCH_CONTEXT();
 
-  batch->Clear();
+  if (!batch->IsShared()) {
+    batch->Clear();
+  } else {
+    napi_throw_error(env, 0, "Unsafe batch clear.");
+  }
 
   NAPI_RETURN_UNDEFINED();
 }
@@ -1985,6 +2011,9 @@ struct BatchWriteWorker final : public PriorityWorker {
     : PriorityWorker(env, batch->database_, callback, "leveldown.batch.write"),
       batch_(batch),
       sync_(sync) {
+        // For thread safety, consider BatchWrite as shared.
+        batch->Share();
+
         // Prevent GC of batch object before we execute
         NAPI_STATUS_THROWS_VOID(napi_create_reference(env, context, 1, &contextRef_));
       }
@@ -1999,6 +2028,7 @@ struct BatchWriteWorker final : public PriorityWorker {
 
   void DoFinally (napi_env env) override {
     napi_delete_reference(env, contextRef_);
+    batch_->Unshare();
     PriorityWorker::DoFinally(env);
   }
 
@@ -2019,6 +2049,12 @@ NAPI_METHOD(batch_write) {
   const bool sync = BooleanProperty(env, options, "sync", false);
   napi_value callback = argv[2];
 
+  if (batch->IsShared()) {
+    napi_value argv = CreateError(env, "Unsafe batch write.");
+    CallFunction(env, callback, 1, &argv);
+    NAPI_RETURN_UNDEFINED();
+  }
+
   BatchWriteWorker* worker  = new BatchWriteWorker(env, argv[0], batch, callback, sync);
   worker->Queue(env);
 
